<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        const Book = function(title, author) {
            this.title = title;
            this.author = author;
            // 가리키는 주소값. 현재 사용중인 객체의 주소를 저장하기 위한 변수
            // console.log(this.title, this.author);
        }
        // 메모리를 만들어 사용
        // Book('노인', '바다')
        let b1 = new Book('노인과 바다', '헤밍웨이');
        console.log(b1.title, b1.author);
        // 다른 메모리에 또 저장
        let b2 = new Book('홍길동전', '허균');
        console.log(b2.title, b2.author);

        // 객체 선언 방식은 객체를 생성할 때마다 초기화해야 하는 속성을 생성자 함수 내에서 설정합니다. 
        // 메소드 추가 방식은 생성된 객체들이 공유할 메소드를 생성자 함수의 prototype에 추가하여 메모리 사용을 최적화하고, 
        // 객체들이 동일한 메소드를 공유하여 중복 생성을 피합니다.
        Book.prototype.setValue = function(title, author) {
            this.title = title;
            this.author = author;
        }

        b1.setValue('노인과 강', '헤밍코드');
        console.log(b1.title, b1.author)

        // 이렇게 메소드를 공유하는 방식은 객체의 속성을 변경하는 데 유용하며, 
        // 객체 간에 메모리를 더 효율적으로 사용할 수 있습니다.

        Book.prototype.toString = function(){
            return this.title + ' [' + this.author + ']';
        }

        console.log(b1.toString());
        console.log(b2.toString());
    </script>
</head>
<body>
    
</body>
</html>