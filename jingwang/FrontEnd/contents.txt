7.19
// 원시소스 (사람이 작성한 소스) (텍스트) 을 컴파일(번역) 하여 컴퓨터 언어 (이진수)
// 크로스 브라우징 : 웹 페이지 제작 시에 모든 브라우저에서 깨지지 않고 의도한 대로 올바르게 나오게 하는 작업
// Entity : 키보드로 쓸 수 없는 특수분자들을 별도로 따로 만들고 불러오는 방법. 참조하는 기술

Visual Studio Code
- 브라우저에 출력
	1) live server 설치
	
HTML(Hyper Text Markup Language)
	https://w3schools.com
	Language : 언어
	Markup : <시작태그> 데이터 </끝태그> 형식
	Hyper Text : 문서간에 연결할 수 있는 기술
	
	뜻 : Web에서 공통으로 쓸 수 있는 정보를 공유하기 위한 언어
	용도 : 문서의 구조를 설정
	역사 : https://namu.wiki/w/HTML
	버전  
		- HTML 4.x
		- XHTML
		- HTML 5.x
	웹 제작시 고려할 사항
		- 웹 표준
		- 웹 접근성
		- 크로스 브라우징
	문법
		- 주석 처리 : <!-- 컨텐츠 -->
		- 태그의 기본 구조
			<열린태그 속성="속성값">컨텐츠</닫힌태그> <<- Element(시작과 끝을 잘 묶어준, 완전히 하나의 구성요소) 라고 함
			<열린태그></닫힌태그> 또는 <열린태그 /> // 컨텐츠가 없을 때
		- 문서의 기본 구조
			<!DOCTYPE html>
			<html>
				<head>
					다양한 메타정보나 선언부
				</head>
				
				<body>
					화면에 보여질 본문 내용
				</body>
			</html>
		- 태그의 종류
			1) <head></head>
				- <title></title>
				- <meta></meta>
					ㄴ <meta name="viewport" content="width=device-width, initial-scale=1.0">
					ㄴ 안해도 상관 없지만 해두면 좋음. 모바일이나 컴퓨터 화면에 알아서 뷰포트를 조절해주는 문장
			2) 글자 꾸미기
				- test2.html
			3) 이미지
				- jpg(jpeg) : 압축률이 뛰어나다.(용량이 작다) 단 여러 번 반복 저장하게 되면 손실율이 매우 높아진다.
				- png : gif 대체 포맷. 비손실 압축. 투명도 지원
				- gif : 비손실 압축. 8비트 색상만 지원. 여러 장의 이미지를 하나의 파일로 묶을 수 있다.
				- webp : jpg, png, gif를 모두 대체할 수 있는 구글에서 개발한 이미지 포맷
				- test3.html
				
				※ 경로 (path)
				- 상대 경로
				- 절대 경로
					ㄴ 로컬 경로 (서버에서는 사용 불가, 내 pc에서는 사용 가능)
					ㄴ 가상 경로
			4) 하이퍼 링크
				※ URL(Uniform Resource Locator)
					네트워크 상에서 자원이 어디 있는지를 알려주기 위한 규약이다. 즉, 컴퓨터 네트워크와 검색 메커니즘에서의 위치를 지정하는, 웹 리소스에 대한 참조이다. 쉽게 말해서, 웹 페이지를 찾기위한 주소를 말한다.
				- 형식
					프로토콜명://도메인주소:포트번호/폴더명/파일명#세부위치
					// http는 프로토콜 (hyper text tranasfer protocol)
					http://
				- test4.html
			5) 테이블
				- test5.html
			6) Input Type : 폼 태그
				- test6.html
================================================================================================================================================
CSS (Cascading Style Sheet)
	개요
		1) 버전
			css 1.x -> css 2.x -> css 3.x > css 4.x
		2) 목적
			- 디자인(HTML 등)의 효과적인 관리(유지보수 등)
			- 웹 표준화(Cross Browsing)
	사용 방법
		1) External Style
			- 별도의 .css파일을 만들어서 호출하여 사용하는 방식
		2) Inline Style
			- 태그 안에서 직접 사용하는 방식
			- style 이라는 속성을 이용
		3) Internal Style
			- 하나의 페이지에 단 한 번만 정의함으로써 같은 페이지내에서는 동일한 디자인을 재사용할 수 있다.
		4) Import Style
			- 외부의 css파일간의 연결(직렬)
	문법
		선택자(Selector) { 속성 : 값; }
		
		1) 선택자(Selector)
			a) 기본 선택자
				- * (전체 선택자)
				- 태그 선택자 : 태그 이름으로 선택
				- 클래스 선택자 : 태그의 class 속성의 값으로 선택 (. 표시)
				- 아이디 선택자 : 태그의 id 속성의 값으로 선택 (# 표시)
			b) 복합 선택자
				- 일치 선택자(Basic Combinator) : 태그.클래스명
				- 자식 선택자(Child Combinator) : 태그 > 클래스명
				- 하위(후손) 선택자(Descendant Combinator) : 태그 .클래스명
				- 인접 형제 선택자(Adjacent Sibling Combinator) : .클래스명 + 태그
				- 일반 형제 선택자(General Sibling Combinator) : .클래스명 ~ 태그
			c) 가상 클래스 선택자(Pseudo Classes Selector) : ":" 을 사용
				- hover : 마우스 커서가 요소 위에 있는 동안 선택
				- active : 마우스를 클릭하고 있는 동안 선택
				- focus : 포커싱이 되면 선택. 모든 걸 포커스가 되는 게 아님.
					input, a, button,label, select 등 주로 대화형 컨텐츠들
				- first-child
				- last-child
				- nth-child
				- not
			d) 가상 요소 선택자(Pseudo Elements Selector) : "::" 사용, 컨텐츠 추가
				- before
				- after
			e) 속성 선택자(Attribute Selector)
				※ 속성이란? <태그명 속성> </태그명>
				[속성명] {...}
				[속성=값] {...}
		2) 디자인 속성값
			- Font 관련 (font, line)
			- 색상 및 이미지 관련(color, background)
			- 텍스트 관련(text, line)
			- 여백(margin, padding, border)
		3) 스타일 상속
			- 현재 요소의 스타일이 자식이나 하위 요소에까지 영향을 미치는 것
			- 주로 글자/문자 관련 속성들이 상속(font, text 관련)
		4) Block 요소와 Inline 요소
			a) Block 요소
				- 줄 바꿈 현상이 나타남
				- width/height 값 사용 가능(공간 만들기 가능)
				- margin(바깥 여백)과 padding(안 쪽 여백) 값 사용 가능(상하 배치 작업 가능)
				- inline 요소를 포함할 수 있다.
				- <div>, <p>, <h>, <ul>, ...
			b) Inline 요소
				- 줄 바꿈 현상이 없음
				- width/height 값 적용 불가
				- margin/padding/bottom 값 적용 불가(좌우 여백은 가능)
				- block 요소를 포함할 수 없다
				- <img>, <a>, <span>, ...
			※ <input> : block 과 inline 두 가지 특징을 모두 가지고 있다.
		5) 디자인 속성
			a) width, height
			- width 는 자동으로 크기가 설정된다.
				<div></div>
				div {
				/*   width:100px; */
					height:100px;
					background-color :orange;
				}
			b) margin, padding
				margin : top, right, bottom, left
				margin : [top, bottom] [left, right[
				ex)
					margin : 20px 20px
				margin : [top] [left, right] [bottom]
				margin : [top right, bottom, left]
				
				padding 도 동일
			c) border
				border : 선-두께 선-종류 선-색상 - 한 번에
				border : width, border-style, border-color - 개별적
			d) 크기 계산 : box-sizing
				- content-box (기본값)
				- border-box
					<div class='item'>hello</div>
					<div class='item'>hello</div>
					
					.item {
					  width: 100px;
					  height: 100px;
					  background-color: orange;
					}

					.item:first-child{
					/* border 4px+4px, padding 20px+20px 총 48px를 빼야 두번째 div랑 크기가 같아짐   */
					/*   width: 52px;
					  height: 52px; */
					/* 자동으로 맞춰짐  */
					  box-sizing: border-box;
					  border: 4px solid red;
					  padding: 20px;
					}
				-------------------------------------------------------
			e) 넘침 제어 : overflow
				- visible : 넘친 내용을 그대로 보여줌
				- hidden : 넘친 내용을 숨김
				- auto : 넘친 내용이 있을 경우에만 잘라내고 스크롤바 생성
				- scroll (거의 안씀)
					<div class="parent">
						<div class="child"></div>
					</div>
					
					.parent{
					  width: 200px;
					  height: 150px;
					  background-color: royalblue;
					  margin: 20px;
					/*   overflow: hidden; */
					  overflow: auto;
					}

					.child{
					  width: 300px;
					  height: 100px;
					  background-color: orange;
					}
				-------------------------------------------------------------------
			f) 출력 : display
				- block, inline, inline-block
				- flex(1차원), grid(2차원), none(화면에서 사라짐)
				- table, table-cell, table-row, ...
			g) 배경 : background
				- background-image: url("경로")
				test.html
			h) 배치
				ㄱ) 기준점 : position
					- static (기본값)
					- relative : 요소 자신을 기준
					- absolute : 위치상 부모 요소를 기준, 가장 많이 사용
					- fixed : 뷰포트(브라우저) 기준, 화면 고정 효과가 있다.
					<div class="wrap">
					  <div class="container">
						<div class="item">1</div>
						<div class="item">2</div>
						<div class="item">3</div>
					  </div>
					</div>
					
					.wrap{
					  width: 400px;
					  height: 300px;
					  background-color: tomato;
					  position: relative;
					}

					.container{
					  width: 300px;
					  background-color: royalblue;
					/*   컨테이너 위치 relative로 잡아주기 */
					  position: static;
					}

					.container .item{
					 border: 4px dashed red;
					 background-color: orange;
					}

					.container .item:nth-child(1){
					  width: 100px;
					  height: 100px;
					}

					.container .item:nth-child(2){
					  width: 140px;
					  height: 70px;
					/*   현재 있던 곳에서 위를 기준으로 30px 왼쪽을 기준으로 60px 떨어져 있음. 근데 실제로 움직인 건 아니고 거의 잔상 느낌 그래서 relative는 잘 쓰이진 않음. 레이아웃이 깨질 수 있음 
					  position: relative; 
					  top: 30px;
					  left: 60px; */
					
					/*   구조상에 부모는 있어도 위치상에 부모가 없음 부모가 없으면 상위 부모를 찾는데 없으면 뷰포트(body)가 기준이 됨
					  하지만 지금 원하는 건 컨테이너가 기준이 되는 것 따라서 컨테이너에 위치를 잡아줌(position)*/
					  position : absolute;
					  bottom: 30px;
					  right: 60px;
					  
					}

					.container .item:nth-child(3){
					  width: 70px;
					  height: 120px;
					}
				-------------------------------------------------
				ㄴ) 방향 지정 :top, bottom, right, left
					- auto : 브라우저가 자동으로 계산
					- 숫자값 지정 : px, em, rem 단위 사용
				ㄷ) Stack Order(요소 쌓임 순서) : z-index
					- 요소에 position 속성의 값이 있는 경우 위에 쌓임 (static 제외)
					- 위의 조건이 같은 경우 z-index 속성의 숫자 값이 높을 수록 위에 쌓임
					- 위의 모든 조건이 같은 경우 HTML의 다음 구조일 수록 위에 쌓임		
				<div class="container">
				  <div class="item">1</div>
				  <div class="item">2</div>
				  <div class="item">3</div>
				</div>

				.container{
				  width: 300px;
				  background-color: royalblue;
				  position: relative;
				}

				.container .item{
				  width: 100px;
				  height: 100px;
				  border: 4px dashed red;
				  background-color: orange;
				}

				.container .item:nth-child(1){
				  position:relative;
				  z-index:1;
				}

				.container .item:nth-child(2){
				  position: absolute;
				  top: 50px;
				  left: 50px;
				  z-index:0;
				}

				.container .item:nth-child(3){
				  position: fixed;
				  z-index:2;
				}
				
				ㄹ) position 의 값으로 absolute, fixed가 지정된 요소는, display 속성이 block으로 변경됨
				<span>123</span>
				
				/* 인라인 요소, 글자 속성 이므로 폭과 높이 적용이 안됨 display: block을 넣으면 가능 */
				span {
				  width: 100px;
				  height: 100px;
				  background: orange;
				  font-size: 40px;
				  position:fixed;
				/*   display: block; */
				}
				-----------------------------------------------------------------------
				ㅁ) flex(정렬) : 1차원 레이아웃의 정렬
					- Flex Container
						- display : 가용한 공간 내에서 크기와 위치를 자동 조정
						- flex-direction : 컨테이너 안에 위치되는 방법 지정
						- flex-wrap : 줄바꿈
						- justify-content : 수직방향의 정렬
						- align-content : 기본 축 내에서 개별 항목을 정렬하는 방법과 유사하게 교차 축에 추가 공간이 있을 때 flex container의 선을 정렬
						- align-items : 세로 축을 기준으로 정렬
					- Flex Item
						- order : item의 순서를 설정
						- flow-grow : 속성이 남는 행 여백을 분배해서 채움
						- flex-shrink : 속성이 레이아웃을 벗어난 아이템 너비를 분배해서 줄이는 방법
						- flex-basis : flex 아이템의 기본 크기 설정
						
				<div class="container">
				  <div class="item">1</div>
				  <div class="item">2</div>
				  <div class="item">3</div>
				</div>
				
				.container {
				  background : royalblue;
				  display: flex;
				}

				.item{
				  width: 100px;
				  height: 100px;
				  border: 3px dashed red;
				  background : orange;
				}
			------------------------------------------------------------------
		6) 전환 : transition
			transition : 속성명 지속시간 타이밍함수 대기시간;
			<div></div>
			
			div {
			  width: 100px;
			  height: 100px;
			  background : orange;
			  transition :
				width 2s, 5s,
				background 2s;
			}

			div:hover {
			  width: 300px;
			  background : royalblue;
			}
		------------------------------------------------------------------------
		7) 변환 : transform
			transform : 변환함수1 변환함수2 변환함수3 ...;
				원근법, 이동, 크기, 회전, 기울임
			- 2D 변환함수
			- 3D 변환함수
			test2.html
================================================================================================================================================
JavaScript
	※ HTML이 웹 페이지의 기본 구조를 담당하고, CSS가 디자인을 담당한다면 JavaScript는 클라이언트 단에서 웹 페이지가 동작하는 것을 담당한다. 웹 페이지를 자동차에 비유하자면, HTML은 자동차의 뼈대, CSS는 자동차의 외관, JavaScript는 자동차의 동력원인 엔진이라고 볼 수 있다.
	
	※ ECMA스크립트란, ECMA-262 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어를 말한다. 자바스크립트를 표준화하기 위해 만들어졌다
	
	- 스크립트 언어
	- 객체 기반 언어
	- 사용 방법
		1) inline 방식
			inline.html
		2) internal 방식
			internal html
		3) external 방식
			external.html
	- 문법
		1) 변수 : 임시 기억(저장) 장소
			- 변수 선언 방법
				var 변수명; (안 쓰는 거 권장)
				let
				const
				01_variable.html
		2) 변수 표기법
			- dash-case(kebab-case)
			- snake_case
			- camelCase
			- PascalCase